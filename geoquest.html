<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoQuest - GPS Territory Capture Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #4CAF50;
            margin-bottom: 10px;
        }

        .game-area {
            background-color: #2d2d2d;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .status-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .status-card {
            background-color: #3d3d3d;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }

        .status-card h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .error {
            background-color: #ff4444;
        }

        .warning {
            background-color: #ff9800;
        }

        .success {
            background-color: #4CAF50;
        }

        .map-container {
            height: 400px;
            background-color: #1a1a1a;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .territory-info {
            margin-top: 20px;
            padding: 15px;
            background-color: #3d3d3d;
            border-radius: 8px;
        }

        .player-path {
            color: #4CAF50;
            font-weight: bold;
        }

        .opponent-path {
            color: #ff4444;
            font-weight: bold;
        }

        .settings {
            background-color: #2d2d2d;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .settings h3 {
            color: #4CAF50;
            margin-bottom: 15px;
        }

        .setting-item {
            margin-bottom: 15px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 5px;
        }

        .setting-item input[type="range"] {
            width: 100%;
        }

        .setting-item input[type="text"] {
            width: 100%;
            padding: 8px;
            background-color: #3d3d3d;
            border: 1px solid #555;
            border-radius: 4px;
            color: white;
        }

        .logs {
            background-color: #1a1a1a;
            padding: 15px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-info { color: #4CAF50; }
        .log-warning { color: #ff9800; }
        .log-error { color: #ff4444; }

        @media (max-width: 768px) {
            .status-panel {
                grid-template-columns: 1fr;
            }
            
            .controls {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è GeoQuest</h1>
            <p>GPS Territory Capture Game</p>
        </div>

        <div class="game-area">
            <div class="status-panel">
                <div class="status-card">
                    <h3>üéØ Game Status</h3>
                    <p id="gameStatus">Ready to start</p>
                    <p id="playerScore">Score: 0</p>
                </div>
                <div class="status-card">
                    <h3>üìç Location</h3>
                    <p id="locationStatus">GPS not started</p>
                    <p id="accuracyStatus">Accuracy: N/A</p>
                </div>
            </div>

            <div class="controls">
                <button id="startGame">Start Game</button>
                <button id="stopGame" disabled>Stop Game</button>
                <button id="completeTerritory" disabled>Complete Territory</button>
                <button id="resetGame">Reset Game</button>
            </div>

            <div class="map-container" id="mapContainer">
                <p style="text-align: center; margin-top: 180px; color: #666;">
                    üó∫Ô∏è Map visualization will appear here when GPS is active
                </p>
            </div>

            <div class="territory-info">
                <h3>Territory Progress</h3>
                <p id="territoryProgress">No active territory</p>
                <p id="pathLength">Path length: 0m</p>
                <p id="circleCompletion">Circle completion: 0%</p>
            </div>
        </div>

        <div class="settings">
            <h3>‚öôÔ∏è Game Settings</h3>
            
            <div class="setting-item">
                <label for="geminiApiKey">Gemini API Key (for AI features):</label>
                <input type="text" id="geminiApiKey" placeholder="Enter your Gemini API key" />
                <small style="color: #999;">Optional: Used for intelligent territory suggestions and game tips</small>
            </div>
            
            <div class="setting-item">
                <label for="minMovement">Minimum movement distance (meters): <span id="minMovementValue">5</span></label>
                <input type="range" id="minMovement" min="1" max="20" value="5" />
                <small style="color: #999;">Filter out GPS jitter by ignoring small movements</small>
            </div>
            
            <div class="setting-item">
                <label for="territoryRadius">Territory completion radius (meters): <span id="territoryRadiusValue">50</span></label>
                <input type="range" id="territoryRadius" min="20" max="200" value="50" />
                <small style="color: #999;">How close you need to be to starting point to complete territory</small>
            </div>
            
            <div class="setting-item">
                <label for="updateInterval">GPS update interval (seconds): <span id="updateIntervalValue">2</span></label>
                <input type="range" id="updateInterval" min="1" max="10" value="2" />
                <small style="color: #999;">Lower values use more battery but provide smoother tracking</small>
            </div>
        </div>

        <div class="logs" id="gameLog">
            <div class="log-entry log-info">üéÆ GeoQuest initialized. Configure settings and start game!</div>
        </div>
    </div>

    <script>
class GeoQuest {
    constructor() {
        this.isGameActive = false;
        this.watchId = null;
        this.currentPath = [];
        this.territories = [];
        this.playerScore = 0;
        this.lastPosition = null;
        this.territoryStartPosition = null;
        this.isCapturingTerritory = false;
        this.opponentTerritories = []; // Simulated opponent territories for demo
        
        // Game settings
        this.settings = {
            minMovementDistance: 5, // meters
            territoryCompletionRadius: 50, // meters
            updateInterval: 2000, // milliseconds
            geminiApiKey: ''
        };
        
        this.initializeUI();
        this.setupEventListeners();
        this.loadSettings();
    }

    initializeUI() {
        // Initialize UI elements
        this.elements = {
            gameStatus: document.getElementById('gameStatus'),
            playerScore: document.getElementById('playerScore'),
            locationStatus: document.getElementById('locationStatus'),
            accuracyStatus: document.getElementById('accuracyStatus'),
            territoryProgress: document.getElementById('territoryProgress'),
            pathLength: document.getElementById('pathLength'),
            circleCompletion: document.getElementById('circleCompletion'),
            gameLog: document.getElementById('gameLog'),
            startBtn: document.getElementById('startGame'),
            stopBtn: document.getElementById('stopGame'),
            completeBtn: document.getElementById('completeTerritory'),
            resetBtn: document.getElementById('resetGame')
        };
    }

    setupEventListeners() {
        // Game controls
        this.elements.startBtn.addEventListener('click', () => this.startGame());
        this.elements.stopBtn.addEventListener('click', () => this.stopGame());
        this.elements.completeBtn.addEventListener('click', () => this.completeTerritory());
        this.elements.resetBtn.addEventListener('click', () => this.resetGame());

        // Settings
        const minMovement = document.getElementById('minMovement');
        const territoryRadius = document.getElementById('territoryRadius');
        const updateInterval = document.getElementById('updateInterval');
        const geminiApiKey = document.getElementById('geminiApiKey');

        minMovement.addEventListener('input', (e) => {
            this.settings.minMovementDistance = parseInt(e.target.value);
            document.getElementById('minMovementValue').textContent = e.target.value;
            this.saveSettings();
        });

        territoryRadius.addEventListener('input', (e) => {
            this.settings.territoryCompletionRadius = parseInt(e.target.value);
            document.getElementById('territoryRadiusValue').textContent = e.target.value;
            this.saveSettings();
        });

        updateInterval.addEventListener('input', (e) => {
            this.settings.updateInterval = parseInt(e.target.value) * 1000;
            document.getElementById('updateIntervalValue').textContent = e.target.value;
            this.saveSettings();
        });

        geminiApiKey.addEventListener('change', (e) => {
            this.settings.geminiApiKey = e.target.value;
            this.saveSettings();
            if (e.target.value) {
                this.log('‚úÖ Gemini API key configured', 'info');
            }
        });
    }

    loadSettings() {
        try {
            const saved = localStorage.getItem('geoquest-settings');
            if (saved) {
                Object.assign(this.settings, JSON.parse(saved));
                this.updateSettingsUI();
            }
        } catch (error) {
            this.log('‚ö†Ô∏è Could not load saved settings', 'warning');
        }
    }

    saveSettings() {
        try {
            localStorage.setItem('geoquest-settings', JSON.stringify(this.settings));
        } catch (error) {
            this.log('‚ö†Ô∏è Could not save settings', 'warning');
        }
    }

    updateSettingsUI() {
        document.getElementById('minMovement').value = this.settings.minMovementDistance;
        document.getElementById('minMovementValue').textContent = this.settings.minMovementDistance;
        
        document.getElementById('territoryRadius').value = this.settings.territoryCompletionRadius;
        document.getElementById('territoryRadiusValue').textContent = this.settings.territoryCompletionRadius;
        
        document.getElementById('updateInterval').value = this.settings.updateInterval / 1000;
        document.getElementById('updateIntervalValue').textContent = this.settings.updateInterval / 1000;
        
        document.getElementById('geminiApiKey').value = this.settings.geminiApiKey;
    }

    async startGame() {
        try {
            this.log('üéÆ Starting GeoQuest game...', 'info');
            
            // Check geolocation support
            if (!navigator.geolocation) {
                throw new Error('Geolocation is not supported by this browser');
            }

            // Request location permission
            await this.requestLocationPermission();
            
            this.isGameActive = true;
            this.updateGameUI();
            
            // Start GPS tracking
            this.startGPSTracking();
            
            this.log('‚úÖ Game started successfully!', 'info');
            
        } catch (error) {
            this.handleGeolocationError(error);
        }
    }

    async requestLocationPermission() {
        return new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    this.log('üìç Location permission granted', 'info');
                    resolve(position);
                },
                (error) => {
                    this.handleGeolocationError(error);
                    reject(error);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        });
    }

    startGPSTracking() {
        const options = {
            enableHighAccuracy: true,
            timeout: 15000,
            maximumAge: 0
        };

        this.watchId = navigator.geolocation.watchPosition(
            (position) => this.handlePositionUpdate(position),
            (error) => this.handleGeolocationError(error),
            options
        );
    }

    handlePositionUpdate(position) {
        const { latitude, longitude, accuracy } = position.coords;
        
        this.elements.locationStatus.textContent = `${latitude.toFixed(6)}, ${longitude.toFixed(6)}`;
        this.elements.accuracyStatus.textContent = `Accuracy: ${accuracy.toFixed(1)}m`;

        // Filter out inaccurate readings
        if (accuracy > 50) {
            this.log(`‚ö†Ô∏è GPS accuracy too low (${accuracy.toFixed(1)}m), ignoring position`, 'warning');
            return;
        }

        const newPosition = { lat: latitude, lng: longitude, timestamp: Date.now(), accuracy };

        // Filter out GPS jitter
        if (this.lastPosition && this.calculateDistance(this.lastPosition, newPosition) < this.settings.minMovementDistance) {
            return; // Ignore small movements to reduce jitter
        }

        this.processNewPosition(newPosition);
        this.lastPosition = newPosition;
    }

    processNewPosition(position) {
        if (!this.isCapturingTerritory) {
            this.startNewTerritory(position);
        } else {
            this.updateTerritoryPath(position);
        }

        this.checkForTerritoryCompletion(position);
        this.checkForOpponentInterference(position);
        this.updateTerritoryUI();
    }

    startNewTerritory(position) {
        this.isCapturingTerritory = true;
        this.territoryStartPosition = position;
        this.currentPath = [position];
        
        this.elements.completeBtn.disabled = false;
        this.log('üéØ Started new territory capture', 'info');
        
        // Get AI suggestion if Gemini API is configured
        if (this.settings.geminiApiKey) {
            this.getTerritorySuggestion(position);
        }
    }

    updateTerritoryPath(position) {
        this.currentPath.push(position);
        
        // Check for self-intersections
        if (this.hasPathSelfIntersection()) {
            this.log('‚ö†Ô∏è Path self-intersection detected! Territory may be invalid', 'warning');
        }
    }

    hasPathSelfIntersection() {
        if (this.currentPath.length < 4) return false;
        
        // Check if the current path segment intersects with any previous segments
        const currentSegment = {
            start: this.currentPath[this.currentPath.length - 2],
            end: this.currentPath[this.currentPath.length - 1]
        };

        for (let i = 0; i < this.currentPath.length - 3; i++) {
            const segment = {
                start: this.currentPath[i],
                end: this.currentPath[i + 1]
            };

            if (this.doSegmentsIntersect(currentSegment, segment)) {
                return true;
            }
        }

        return false;
    }

    doSegmentsIntersect(seg1, seg2) {
        // Line segment intersection algorithm
        const det = (a, b, c) => (b.lat - a.lat) * (c.lng - a.lng) - (b.lng - a.lng) * (c.lat - a.lat);
        
        const d1 = det(seg2.start, seg2.end, seg1.start);
        const d2 = det(seg2.start, seg2.end, seg1.end);
        const d3 = det(seg1.start, seg1.end, seg2.start);
        const d4 = det(seg1.start, seg1.end, seg2.end);
        
        return ((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && 
               ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0));
    }

    checkForTerritoryCompletion(position) {
        if (!this.isCapturingTerritory || !this.territoryStartPosition) return;

        const distanceToStart = this.calculateDistance(position, this.territoryStartPosition);
        
        if (distanceToStart <= this.settings.territoryCompletionRadius) {
            // Player is close to starting point - territory can be completed
            this.elements.completeBtn.style.backgroundColor = '#4CAF50';
            this.elements.completeBtn.textContent = 'Complete Territory (Ready!)';
        } else {
            this.elements.completeBtn.style.backgroundColor = '#666';
            this.elements.completeBtn.textContent = 'Complete Territory';
        }
    }

    checkForOpponentInterference(position) {
        // Simulate opponent interference - in a real game this would check against other players
        for (const territory of this.opponentTerritories) {
            if (this.isPointInPolygon(position, territory.path)) {
                this.log('üö® Another player has captured this area! Restart required', 'error');
                this.resetCurrentTerritory();
                return;
            }
        }
    }

    isPointInPolygon(point, polygon) {
        // Ray casting algorithm for point-in-polygon test
        let inside = false;
        
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
            const xi = polygon[i].lat, yi = polygon[i].lng;
            const xj = polygon[j].lat, yj = polygon[j].lng;
            
            if (((yi > point.lng) !== (yj > point.lng)) &&
                (point.lat < (xj - xi) * (point.lng - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }
        
        return inside;
    }

    completeTerritory() {
        if (!this.isCapturingTerritory || this.currentPath.length < 3) {
            this.log('‚ùå Cannot complete territory - insufficient path data', 'error');
            return;
        }

        const lastPosition = this.currentPath[this.currentPath.length - 1];
        const distanceToStart = this.calculateDistance(lastPosition, this.territoryStartPosition);

        if (distanceToStart > this.settings.territoryCompletionRadius) {
            this.log('‚ùå Cannot complete territory - not close enough to starting point', 'error');
            return;
        }

        // Close the polygon by connecting back to start
        this.currentPath.push(this.territoryStartPosition);

        // Create territory
        const territory = {
            id: Date.now(),
            path: [...this.currentPath],
            area: this.calculatePolygonArea(this.currentPath),
            completedAt: new Date(),
            isValid: !this.hasPathSelfIntersection()
        };

        if (territory.isValid) {
            this.territories.push(territory);
            this.playerScore += Math.floor(territory.area);
            this.log(`‚úÖ Territory completed! Area: ${territory.area.toFixed(1)}m¬≤`, 'info');
        } else {
            this.log('‚ùå Territory invalid due to self-intersections', 'error');
        }

        this.resetCurrentTerritory();
        this.updateScoreUI();
    }

    resetCurrentTerritory() {
        this.isCapturingTerritory = false;
        this.currentPath = [];
        this.territoryStartPosition = null;
        this.elements.completeBtn.disabled = true;
        this.elements.completeBtn.style.backgroundColor = '#666';
        this.elements.completeBtn.textContent = 'Complete Territory';
    }

    calculateDistance(pos1, pos2) {
        // Haversine formula for calculating distance between two GPS coordinates
        const R = 6371000; // Earth's radius in meters
        const dLat = this.toRadians(pos2.lat - pos1.lat);
        const dLng = this.toRadians(pos2.lng - pos1.lng);
        
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(this.toRadians(pos1.lat)) * Math.cos(this.toRadians(pos2.lat)) *
                  Math.sin(dLng/2) * Math.sin(dLng/2);
        
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    calculatePolygonArea(path) {
        if (path.length < 3) return 0;
        
        // Shoelace formula for polygon area
        let area = 0;
        for (let i = 0; i < path.length - 1; i++) {
            area += (path[i].lng * path[i + 1].lat) - (path[i + 1].lng * path[i].lat);
        }
        
        // Convert to square meters (approximate)
        return Math.abs(area) * 111320 * 111320 / 2;
    }

    toRadians(degrees) {
        return degrees * (Math.PI / 180);
    }

    updateTerritoryUI() {
        if (!this.isCapturingTerritory) {
            this.elements.territoryProgress.textContent = 'No active territory';
            this.elements.pathLength.textContent = 'Path length: 0m';
            this.elements.circleCompletion.textContent = 'Circle completion: 0%';
            return;
        }

        const pathLength = this.calculatePathLength();
        const circleCompletion = this.calculateCircleCompletion();

        this.elements.territoryProgress.textContent = `Capturing territory (${this.currentPath.length} points)`;
        this.elements.pathLength.textContent = `Path length: ${pathLength.toFixed(1)}m`;
        this.elements.circleCompletion.textContent = `Circle completion: ${circleCompletion.toFixed(1)}%`;
    }

    calculatePathLength() {
        let totalLength = 0;
        for (let i = 1; i < this.currentPath.length; i++) {
            totalLength += this.calculateDistance(this.currentPath[i-1], this.currentPath[i]);
        }
        return totalLength;
    }

    calculateCircleCompletion() {
        if (!this.territoryStartPosition || this.currentPath.length < 2) return 0;
        
        const currentPosition = this.currentPath[this.currentPath.length - 1];
        const distanceToStart = this.calculateDistance(currentPosition, this.territoryStartPosition);
        const maxDistance = this.settings.territoryCompletionRadius;
        
        return Math.max(0, Math.min(100, (maxDistance - distanceToStart) / maxDistance * 100));
    }

    updateScoreUI() {
        this.elements.playerScore.textContent = `Score: ${this.playerScore}`;
    }

    updateGameUI() {
        if (this.isGameActive) {
            this.elements.gameStatus.textContent = 'Game Active';
            this.elements.startBtn.disabled = true;
            this.elements.stopBtn.disabled = false;
        } else {
            this.elements.gameStatus.textContent = 'Game Stopped';
            this.elements.startBtn.disabled = false;
            this.elements.stopBtn.disabled = true;
            this.elements.completeBtn.disabled = true;
        }
    }

    stopGame() {
        this.isGameActive = false;
        
        if (this.watchId) {
            navigator.geolocation.clearWatch(this.watchId);
            this.watchId = null;
        }

        this.resetCurrentTerritory();
        this.updateGameUI();
        this.elements.locationStatus.textContent = 'GPS stopped';
        this.elements.accuracyStatus.textContent = 'Accuracy: N/A';
        
        this.log('üõë Game stopped', 'info');
    }

    resetGame() {
        this.stopGame();
        this.territories = [];
        this.playerScore = 0;
        this.currentPath = [];
        this.lastPosition = null;
        
        this.updateScoreUI();
        this.updateTerritoryUI();
        
        this.log('üîÑ Game reset', 'info');
    }

    handleGeolocationError(error) {
        let message = 'Unknown geolocation error';
        let suggestion = '';

        switch(error.code) {
            case error.PERMISSION_DENIED:
                message = 'Location access denied by user';
                suggestion = 'Please enable location permissions in your browser settings and reload the page';
                break;
            case error.POSITION_UNAVAILABLE:
                message = 'Location information unavailable';
                suggestion = 'Please check your GPS is enabled and you have a clear view of the sky';
                break;
            case error.TIMEOUT:
                message = 'Location request timed out';
                suggestion = 'Please check your internet connection and GPS signal';
                break;
        }

        this.log(`‚ùå GPS Error: ${message}`, 'error');
        if (suggestion) {
            this.log(`üí° Suggestion: ${suggestion}`, 'info');
        }

        this.elements.locationStatus.textContent = 'GPS Error';
        this.elements.accuracyStatus.textContent = message;
    }

    async getTerritorySuggestion(position) {
        if (!this.settings.geminiApiKey) return;

        try {
            // This would integrate with Gemini API for AI-powered territory suggestions
            this.log('ü§ñ Getting AI territory suggestion...', 'info');
            
            // Placeholder for Gemini API integration
            // In a real implementation, you would call the Gemini API here
            const suggestion = await this.callGeminiAPI(position);
            
            if (suggestion) {
                this.log(`ü§ñ AI Suggestion: ${suggestion}`, 'info');
            }
        } catch (error) {
            this.log('‚ö†Ô∏è Could not get AI suggestion', 'warning');
        }
    }

    async callGeminiAPI(position) {
        // Placeholder for Gemini API integration
        // This would make an actual API call to Gemini
        if (!this.settings.geminiApiKey) {
            throw new Error('No API key configured');
        }

        // Simulate API call delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Return a mock suggestion
        return "Consider creating a circular territory to maximize area efficiency while minimizing walking distance.";
    }

    log(message, type = 'info') {
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry log-${type}`;
        logEntry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
        
        this.elements.gameLog.appendChild(logEntry);
        this.elements.gameLog.scrollTop = this.elements.gameLog.scrollHeight;
        
        // Keep only last 50 log entries
        while (this.elements.gameLog.children.length > 50) {
            this.elements.gameLog.removeChild(this.elements.gameLog.firstChild);
        }
    }
}

// Initialize the game when page loads
document.addEventListener('DOMContentLoaded', () => {
    const game = new GeoQuest();
    
    // Add some demo opponent territories for testing
    game.opponentTerritories = [
        {
            id: 'opponent1',
            path: [
                { lat: 37.7749, lng: -122.4194 },
                { lat: 37.7750, lng: -122.4194 },
                { lat: 37.7750, lng: -122.4193 },
                { lat: 37.7749, lng: -122.4193 }
            ]
        }
    ];
    
    // Make game instance available globally for debugging
    window.geoQuest = game;
});
    </script>
</body>
</html>